import { DateTime } from "luxon";
import { z } from "zod";

import { rustFetch } from "~/lib/rust-fetch";

import { getApiKey, getEmployeeId } from "./keyring";

const BASE_URL = "https://iofinnethr.bamboohr.com";

export async function assertIsValid({
  bambooEmployeeId,
  bambooApiKey,
}: {
  bambooEmployeeId: string | null | undefined;
  bambooApiKey: string | null | undefined;
}): Promise<void> {
  if (!bambooApiKey) {
    throw new Error("BambooHR API key is empty");
  }

  const credentials = btoa(`${bambooApiKey}:x`);

  const date = DateTime.utc().toISODate();
  const response = await rustFetch(
    `${BASE_URL}/api/v1/time_tracking/timesheet_entries?start=${date}&end=${date}&employeeIds=${bambooEmployeeId}`,
    {
      method: "GET",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/json",
      },
    },
  );

  if (!response.ok) {
    throw new Error("failed to access BambooHR API with the provided key", {
      cause: new Error(await response.text()),
    });
  }
}

const TimesheetEntrySchema = z
  .object(
    {
      id: z.number("invalid entry ID"),
      date: z.iso.date(),
      hours: z.number("invalid hours"),
      timezone: z.string("invalid timezone").refine((v) => DateTime.local().setZone(v).isValid),
      note: z.string().optional(),
      projectInfo: z.object(
        {
          project: z.object({
            id: z.number("invalid project ID"),
            name: z.string("invalid project name"),
          }),
          task: z.object({
            id: z.number("invalid task ID"),
            name: z.string("invalid task name"),
          }),
        },
        "invalid project info",
      ),
    },
    "invalid timesheet entry",
  )
  .transform(({ date, ...v }) => ({ ...v, dateStr: date }));

export async function getTimesheetEntries({
  start,
  end,
}: {
  start: DateTime;
  end: DateTime;
}): Promise<readonly z.infer<typeof TimesheetEntrySchema>[]> {
  const apiKey = await getApiKey();
  const employeeId = await getEmployeeId();
  const credentials = btoa(`${apiKey}:x`);

  const response = await rustFetch(
    `${BASE_URL}/api/v1/time_tracking/timesheet_entries?start=${start.toISODate()}&end=${end.toISODate()}&employeeIds=${employeeId}`,
    {
      method: "GET",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/json",
      },
    },
  );

  if (!response.ok) {
    const text = await response.text();
    throw new Error("failed to get timesheet entries", {
      cause: new Error(text),
    });
  }

  const rawResponse = await response.json();
  const parsed = z.array(z.any()).parse(rawResponse);
  return parsed.map((it) => TimesheetEntrySchema.safeParse(it).data).filter((it) => it !== undefined);
}

export const BambooTaskId = {
  Dev: 17,
  Meetings: 13,
  OneOnOnes: 12,
} as const;

export const TimesheetEntryInput = z.object({
  googleEventId: z.string().nullish(),
  date: z.coerce.date("invalid date"),
  hours: z.number("invalid hours").min(0.5).max(8),
  taskId: z.enum(BambooTaskId, "invalid task ID"),
  note: z
    .string()
    .trim()
    .nullish()
    .optional()
    .transform((v) => v ?? undefined),
});

export async function addTimesheetEntries({
  entries: entriesParam,
}: {
  entries: readonly z.input<typeof TimesheetEntryInput>[];
}): Promise<void> {
  const apiKey = await getApiKey();
  const employeeId = await getEmployeeId();
  const entries = z.array(TimesheetEntryInput).parse(entriesParam);
  const credentials = btoa(`${apiKey}:x`);

  const response = await rustFetch(`${BASE_URL}/api/v1/time_tracking/hour_entries/store`, {
    method: "POST",
    headers: {
      Authorization: `Basic ${credentials}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      hours: entries.map((entry) => {
        return {
          employeeId: employeeId,
          date: DateTime.fromJSDate(entry.date).toISODate(),
          hours: entry.hours,
          projectId: 8,
          taskId: entry.taskId,
          note: [
            entry.note,
            "\n---",
            "---Do not modify!!",
            entry.googleEventId ? `---Google event ID: ${entry.googleEventId}` : undefined,
            `---Generated by io.timesheets at ${DateTime.utc().toISO()}`,
          ]
            .filter((it) => !!it)
            .join("\n")
            .trim(),
        };
      }),
    }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error("failed to get timesheet entries", {
      cause: new Error(text),
    });
  }
}

export async function deleteTimesheetEntries({ entryIds }: { entryIds: readonly number[] }): Promise<void> {
  const apiKey = await getApiKey();
  const credentials = btoa(`${apiKey}:x`);

  const response = await rustFetch(`${BASE_URL}/api/v1/time_tracking/hour_entries/delete`, {
    method: "POST",
    headers: {
      Authorization: `Basic ${credentials}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ hourEntryIds: entryIds }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error("failed to get timesheet entries", {
      cause: new Error(text),
    });
  }
}
